<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="fonts/geosanslight/stylesheet.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<body>
    <div id="drawing"></div>
  </body>
<script type="text/javascript" src="js/svg.min.js"></script>
<script type="text/javascript" src="js/gl-matrix-min.js"></script>
<script type="text/javascript" src="js/opentype.min.js"></script>

<!-- widgets -->
<script type="text/javascript" src="js/widget_location.js"></script>

<script type="text/javascript" src="js/utils/labels.js"></script>
<script type="text/javascript" src="js/utils/perspective.js"></script>
<script type="text/javascript" src="js/widget_text_forecast.js"></script>
<script type="text/javascript" src="js/widget_date.js"></script>
<script type="text/javascript" src="js/widget_time.js"></script>
<script type="text/javascript" src="js/widget_rose.js"></script>


Update rates for widgets (e.g. 1s for time, 1 min for solar position, 1 day for tracks, 1 hour for forecast)
Icons/sprite sheet
SVG file to be read to get rectangle map.
Widgets should take a rectangle as input (to configure their region).
Should be updated with update() every update interval.
Styling should be factored out in palettes, sizes, etc.
Split compass rose/transits/positions into separate widgets operating on common group (w/different update rates)
Update w/o flicker
Fix font labels on compass rose

<script>

    

   

    

    // Fetch a URL (via GET), parse as JSON and
    // send to the given callback
    function request(url, callback)
    {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                callback(JSON.parse(this.responseText));
            }
        };
        request.open('GET', url);
        request.send();
    }

    var draw = SVG('drawing').size(1080, 1920);
    var rect = draw.rect(1080, 1920).attr({ fill: '#000' })
    var time_group = draw.group()
    

    var second_timer = setInterval(updateSecond,1000);

    

  

    //bold_dictionary({"k":"value"}, {"fill":"#fff"}, {"fill":"#888"});

    baseline = 1920-80;
    locationText = draw.text("gegeg");
    locationText.move(40, baseline).id("text_style").font({'font-size':24});

    function sph2cart(az, el)
    {
        var v1 = [Math.cos(el) * Math.sin(az), -Math.sin(el), Math.cos(el) * Math.cos(az)];            
        return v1;
    }

    function draw_spherical_path(path, upper_side)
    {
        var coords = [];
        path.forEach(function(entry) {
            
            var az = entry.az;
            var el =  entry.alt;
            var v1 = sph2cart(az,el);
            // spherical to cartesian
            // should detect breaks and split the polyline
            if(v1[1]*upper_side<=0)            
            {                           
                coords.push(v1);            
            }        
        });
        
        stroke_polyline = perspective_polyline(coords);
        return stroke_polyline;
    }

    

    function draw_transits(json)
    {
        sun_path = json.sun;
        moon_path = json.moon;

        // draw the rose and various guides
        
        var day_moon_polyline = draw_spherical_path(moon_path, 1);        
        var day_sun_polyline = draw_spherical_path(sun_path, 1);

        var night_sun_polyline = draw_spherical_path(sun_path, -1); // -1 to show night side (below horizon)
        var night_moon_polyline = draw_spherical_path(moon_path, -1);
        compass_group.add(day_sun_polyline.stroke({"color":"#fff", "width":0.01}).fill({"color":"none"}));
        compass_group.add(night_sun_polyline.stroke({"color":"#337", "width":0.01}).fill({"color":"none"}));

        compass_group.add(day_moon_polyline.stroke({"color":"#ff8", "width":0.01, "dasharray":0.03}).fill({"color":"none"}));
        compass_group.add(night_moon_polyline.stroke({"color":"#117", "width":0.01, "dasharray":0.03}).fill({"color":"none"}));                        
    }

    function draw_analemma(json)
    {
        sun_analemma = json.sun;                
        var analemma_polyline = draw_spherical_path(sun_analemma, 0); // 0 for both sides        

        compass_group.add(analemma_polyline.stroke({"color":"#ff2", "width":0.01}).fill({"color":"none"}));                
    }

    function draw_symbol(obj, sym, font_size)
    {
        var group = draw.group();
        var v1 = sph2cart(obj.az, obj.alt);        
        var vpos = ftransform(v1);
        var color = '#fff';
        console.log(sym,v1,obj);
        if(obj.alt<0)
        {
         color = '#44d';   
        }
        var back = draw.circle(font_size*0.9).fill("#000").move(vpos[0]-font_size*0.4, vpos[1]-font_size*0.3);
        text = perspective_text(v1, sym, font_size).id("text_style").style({"fill":color});
        
        hline = perspective_line(v1, [v1[0], 0, v1[2]], 0.005).stroke({"color":"#fff", "dasharray":0.03});
        vline = perspective_line([0,0,0], [v1[0], 0, v1[2]], 0.005).stroke({"color":"#fff", "dasharray":0.03});
        hypline = perspective_line([0,0,0], v1, 0.005).stroke({"color":"#fff", "dasharray":0.03});

     
        
        group.add(hline);
        group.add(vline);
        group.add(hypline);
        //group.add(back);
        group.add(text);

        return group;
    }

    function deg(rad)
    {
        return (rad/Math.PI)*180.0;
    }

     function draw_locations(json)
    {
        console.log(json);
        var sun_pos = json.sun;
        sun_symbol = draw_symbol(json.sun, '☉', 0.2, Math.floor(deg(json.sun.alt))+"°", 0.1);
        moon_symbol = draw_symbol(json.moon, '☽', 0.15, Math.floor(deg(json.moon.alt))+"°", 0.1);
        
        
        compass_group.add(sun_symbol);        
        compass_group.add(moon_symbol);                
    }

    request("/astro/transits", json=>{draw_transits(json)});
    request("/astro/analemma", json=>{draw_analemma(json)});
    request("/astro/locations", json=>{draw_locations(json)});

   
    function updateSecond()
    {        
        request('/keepalive', json => {});
    }

    // Widgets registered here
    widgets = {"forecast":widget_forecast, 
              "location":widget_location,
              "date":widget_date,
              "time":widget_time};

    
    // Update all widgets
    for(widget in widgets) {if(widgets[widget].init) widgets[widget].init();}
    for(widget in widgets) {widgets[widget].update();}

    
</script>
