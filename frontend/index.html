<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="fonts/geosanslight/stylesheet.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<body>
    <div id="drawing"></div>    
  </body>
<script type="text/javascript" src="js/extern/svg.min.js"></script>
<script type="text/javascript" src="js/extern/gl-matrix-min.js"></script>
<script type="text/javascript" src="js/extern/opentype.min.js"></script>

<!-- widgets -->
<script type="text/javascript" src="js/widget_location.js"></script>

<script type="text/javascript" src="js/utils/labels.js"></script>
<script type="text/javascript" src="js/utils/perspective.js"></script>
<script type="text/javascript" src="js/widget_text_forecast.js"></script>
<script type="text/javascript" src="js/widget_date.js"></script>
<script type="text/javascript" src="js/widget_time.js"></script>
<script type="text/javascript" src="js/widget_rose.js"></script>
<script type="text/javascript" src="js/widget_big_temperature.js"></script>


Update rates for widgets (e.g. 1s for time, 1 min for solar position, 1 day for tracks, 1 hour for forecast)
Icons/sprite sheet
Should be updated with update() every update interval.
Styling should be factored out in palettes, sizes, etc.
Update w/o flicker
Separate updates for data sources from updates to widgets that depend on them.

<script>

    // Fetch a URL (via GET), parse as JSON and
    // send to the given callback
    function request(url, callback)
    {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                callback(JSON.parse(this.responseText));
            }
        };
        request.open('GET', url);
        request.send();
    }

    

    // Fetch a URL (via GET), 
    // send to the given callback (as a raw string)
    function raw_request(url, callback)
    {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                callback(this.responseText);
            }
        };
        request.open('GET', url);
        request.send();
    }

    var draw = SVG('drawing').size(1080, 1920);
    var rect = draw.rect(1080, 1920).attr({ fill: '#000' })
    var time_group = draw.group()
    



    

  

    //bold_dictionary({"k":"value"}, {"fill":"#fff"}, {"fill":"#888"});

    
   


    function deg(rad)
    {
        return (rad/Math.PI)*180.0;
    }

    
   

   
    
    // Widgets registered here
    widgets = {"today_forecast":widget_forecast, 
                "gnomon":widget_rose,
              "location":widget_location,
              "date":widget_date,
              "time":widget_time,
              "main_temperature":widget_temp};

    
// from https://stackoverflow.com/questions/10073699/pad-a-number-with-leading-zeros-in-javascript
function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}
// end

config = {
    inshore_area:"iw18",
    station_id:"353917",
}

// sources of data, fetched with request
// json passed to the update function when updates happen
// update always happens at launch, then on the schedule
// given. updates always happen at most 1 second past the 
// turnover for that period (e.g. daily between 00:00:00 and 00:00:01)
data_sources = {
    'forecast' : {
        url:'/metoffice/forecast/'+config.station_id,
        update:'hourly',
        deps:[]
    },
    'time' : {
        url:'/time',
        update:'minute',
        deps:["time"]
    },
    'date' : {
        url:'/date',
        update:'day',
        deps:["date"]
    },
    'inshore_forecast' : 
    {
        url:'/metoffice/inshore_forecast/'+config.inshore_area,
        update:'hour',
        deps:["text_forecast"],
    },
    'locations' : 
    {
        url:'/astro/locations',
        update:'minute',
        deps:["astro_locations"],
    },
    'transits' : 
    {
        url:'/astro/transits',
        update:'day',
        deps:["astro_transits"],
    },
    'solar_day' : 
    {
        url:'/astro/solar_day',
        update:'day',
        deps:["astro_day", "day_timeseries"],
    },
    'analemma' : 
    {
        url:'/astro/analemma',
        update:'minute',
        deps:["astro_analemma"],
    },
    'keepalive' : 
    {
        url:'keepalive',
        update:'second',
        deps:["heartbeat"],
    }  
}

// initially, nothing has been latched; will be updated
// in schedule_fetch
var schedule_latches = {    }

function update_datasource(data)
{
    // fetch data (even if no deps)
    request(data.url, function(json)
        {             
            data.json = json; // cache data                  
            //update required, find dependent widgets
            if(data.deps)
            {                    
                data.deps.forEach(function(dep)
                {                        
                    var update_widget = widgets[dep];                    
                    if(update_widget)
                    {
                        console.log(update_widget, data.json);
                        // pass the JSON for this update to the widget that depends on it
                        //update_widget.update(data.json);
                    }
                });
            }
        });
}

function schedule_fetch()
{
    //Check the time; see what flags need updating; 
    //then fetch any data waiting, and update the widgets that depend on this data
    var now = new Date();
    var flags = [];
            
    var updates = {second:now.getSeconds(), minute:now.getMinutes(), hour:now.getHours(), day:now.getDate(), month:now.getMonth(), once:"once"};
    for(var name in updates)
    {        
        if(updates[name]!=schedule_latches[name])
        {
            flags.push(name);
            schedule_latches[name] = updates[name];
        }
    }  
    // now refresh all of the data sources
    for(var source in data_sources)
    {
        var data = data_sources[source];                
        if(flags.indexOf(data.update)!=-1)
        {    
            console.log(data.url, data.deps);        
            update_datasource(data);            
        }
    }
    
}


    schedule_fetch(); // initial call to scheduler on start

    // call the scheduler
    function updateSecond()
    {                
        schedule_fetch();
    }
    var second_timer = setInterval(updateSecond,1000);
    

    var skeleton_group;
       // Get the skeleton document which has the layout information
       raw_request("/assets/prototype_8_skeleton.svg", svg=>{
        skeleton_group = draw.group();
        skeleton_group.svg(svg);
        skeleton_group.attr({'visibility':'hidden'})

        // Update all widgets
        for(widget in widgets) 
        {
            if(widgets[widget].init) 
            {
                var skeleton_widget = SVG.get(widget);
                
                if(skeleton_widget)
                {
                   bbox = skeleton_widget.rbox(draw);                
                   draw.rect(bbox.w, bbox.h).move(bbox.x,bbox.y).fill('none').stroke('#f0f');
                }
                else
                    bbox = {w:0, h:0, x:0, y:0};
                widgets[widget].init(bbox);
            
            }
        }
        for(widget in widgets) {widgets[widget].update();}

        });

    

  

                
      
    
</script>
