<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="fonts/geosanslight/stylesheet.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<body>
    <div id="drawing"></div>
  </body>
<script type="text/javascript" src="js/svg.min.js"></script>
<script type="text/javascript" src="js/gl-matrix-min.js"></script>

<!-- widgets -->
<script type="text/javascript" src="js/widget_location.js"></script>
<script type="text/javascript" src="js/perspective.js"></script>
<script type="text/javascript" src="js/widget_text_forecast.js"></script>
<script type="text/javascript" src="js/widget_date.js"></script>
<script type="text/javascript" src="js/widget_time.js"></script>

Fix exact text layout.
Update rates for widgets (e.g. 1s for time, 1 min for solar position, 1 day for tracks, 1 hour for forecast)
Icons/sprite sheet
SVG file to be read to get rectangle map.
Widgets should take a rectangle as input (to configure their region).
Should be updated with update() every update interval.
Styling should be factored out in palettes, sizes, etc.
Split compass rose/transits/positions into separate widgets operating on common group (w/different update rates)
Update w/o flicker
<script>

    

    function compass()
    {        
        var rose = draw.group();
        var i;
        var inner_rad = 0.9;
        var min_rad = 1.0;
        var maj_rad = 1.2;
        var n = 72;
        var width = 0.002;
        
        for(i=0;i<n;i++)
        {
            var angle = (i/n) * 2 * Math.PI;
            var cx = Math.cos(angle);
            var cy = -Math.sin(angle);
            
            var irad = inner_rad;
            var rad = min_rad;
            var w = width;
            if(i%(n/8)==0)
            {
                irad *= 0.8;
                rad = min_rad * 1.0;
                w *= 1.5;
            }
            if(i%(n/4)==0)
            {
                irad *= 0.8;
                rad = min_rad * 1;
                w *= 2;
            }
            
            if(i%2==0)
            {
                w *= 2;
            }            
            
            var inner_x = cx * irad;
            var inner_y = cy * irad;
            var min_outer_x = cx * rad;
            var min_outer_y = cy * rad;   

            rose.add(perspective_line([inner_x, 0, inner_y], [min_outer_x, 0, min_outer_y], w).style({"stroke":"#fff"}));
        }

        // Outer circles and hemisphere
        var scale = mat4.create();
        mat4.scale(scale, scale, [min_rad, min_rad, min_rad]);
        rose.add(perspective_circle(scale).stroke({"color":"#fff", "width":0.01}).fill({"color":"none"}));

        mat4.rotate(scale, scale, Math.PI/2, [1,0,0]);        
        rose.add(perspective_circle(scale, Math.PI, Math.PI*2).stroke({"color":"#fff", "width":0.0025, "stroke-dasharray":"0.02"}).fill({"color":"none"}));

        mat4.rotate(scale, scale, Math.PI/2, [0,0,1]);        
        rose.add(perspective_circle(scale, Math.PI, Math.PI*2).stroke({"color":"#fff", "width":0.0025, "stroke-dasharray":"0.02"}).fill({"color":"none"}));

        // Inner circle
        mat4.identity(scale);
        mat4.scale(scale, scale, [inner_rad, inner_rad, inner_rad]);
        //rose.add(perspective_circle(scale).stroke({"color":"#fff", "width":0.0025}).fill({"color":"none"}));

        // Vertical line
        rose.add(perspective_line([0,0,0], [0,-min_rad,0], w).style({"stroke":"#fff", "stroke-dasharray":"0.01"}));       
        
        sz = 0.18;
        var rad = 1.2;
        rose.add(perspective_text([0,0,rad], 'N', sz).id('text_style'));
        rose.add(perspective_text([0,0,-rad], 'S', sz).id('text_style'));
        rose.add(perspective_text([rad,0,0], 'E', sz).id('text_style'));
        rose.add(perspective_text([-rad,0,0], 'W', sz).id('text_style'));
        
        var deg45 = Math.cos(Math.PI/4)*rad;
        sz = 0.1;
        rose.add(perspective_text([deg45,0,deg45], 'NE', sz).id('text_style'));
        rose.add(perspective_text([-deg45,0,deg45], 'NW', sz).id('text_style'));
        rose.add(perspective_text([-deg45,0,-deg45], 'SW', sz).id('text_style'));
        rose.add(perspective_text([deg45,0,-deg45], 'SE', sz).id('text_style'));
        
        return rose;
    }

    

    // Fetch a URL (via GET), parse as JSON and
    // send to the given callback
    function request(url, callback)
    {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                callback(JSON.parse(this.responseText));
            }
        };
        request.open('GET', url);
        request.send();
    }

    var draw = SVG('drawing').size(1080, 1920);
    var rect = draw.rect(1080, 1920).attr({ fill: '#000' })
    var time_group = draw.group()
    

    var second_timer = setInterval(updateSecond,1000);

    

  

    //bold_dictionary({"k":"value"}, {"fill":"#fff"}, {"fill":"#888"});

    baseline = 1920-80;
    locationText = draw.text("gegeg");
    locationText.move(40, baseline).id("text_style").font({'font-size':24});

    function sph2cart(az, el)
    {
        var v1 = [Math.cos(el) * Math.sin(az), -Math.sin(el), Math.cos(el) * Math.cos(az)];            
        return v1;
    }

    function draw_spherical_path(path, upper_side)
    {
        var coords = [];
        path.forEach(function(entry) {
            
            var az = entry.az;
            var el =  entry.alt;
            var v1 = sph2cart(az,el);
            // spherical to cartesian
            // should detect breaks and split the polyline
            if(v1[1]*upper_side<=0)            
            {                           
                coords.push(v1);            
            }        
        });
        
        stroke_polyline = perspective_polyline(coords);
        return stroke_polyline;
    }

    var compass_group = compass();
    var compass_rose = compass_group.scale(200.0,200.0).translate(500,900);

    function draw_transits(json)
    {
        sun_path = json.sun;
        moon_path = json.moon;

        // draw the rose and various guides
        
        var day_moon_polyline = draw_spherical_path(moon_path, 1);        
        var day_sun_polyline = draw_spherical_path(sun_path, 1);

        var night_sun_polyline = draw_spherical_path(sun_path, -1); // -1 to show night side (below horizon)
        var night_moon_polyline = draw_spherical_path(moon_path, -1);
        compass_group.add(day_sun_polyline.stroke({"color":"#fff", "width":0.01}).fill({"color":"none"}));
        compass_group.add(night_sun_polyline.stroke({"color":"#337", "width":0.01}).fill({"color":"none"}));

        compass_group.add(day_moon_polyline.stroke({"color":"#ff8", "width":0.01, "dasharray":0.03}).fill({"color":"none"}));
        compass_group.add(night_moon_polyline.stroke({"color":"#117", "width":0.01, "dasharray":0.03}).fill({"color":"none"}));                        
    }

    function draw_analemma(json)
    {
        sun_analemma = json.sun;                
        var analemma_polyline = draw_spherical_path(sun_analemma, 0); // 0 for both sides        

        compass_group.add(analemma_polyline.stroke({"color":"#ff2", "width":0.01}).fill({"color":"none"}));                
    }

    function draw_symbol(obj, sym, font_size)
    {
        var group = draw.group();
        var v1 = sph2cart(obj.az, obj.alt);        
        var vpos = ftransform(v1);
        var color = '#fff';
        console.log(sym,v1,obj);
        if(obj.alt<0)
        {
         color = '#44d';   
        }
        var back = draw.circle(font_size*0.9).fill("#000").move(vpos[0]-font_size*0.4, vpos[1]-font_size*0.3);
        text = perspective_text(v1, sym, font_size).id("text_style").style({"fill":color});
        
        hline = perspective_line(v1, [v1[0], 0, v1[2]], 0.005).stroke({"color":"#fff", "dasharray":0.03});
        vline = perspective_line([0,0,0], [v1[0], 0, v1[2]], 0.005).stroke({"color":"#fff", "dasharray":0.03});
        hypline = perspective_line([0,0,0], v1, 0.005).stroke({"color":"#fff", "dasharray":0.03});

     
        
        group.add(hline);
        group.add(vline);
        group.add(hypline);
        //group.add(back);
        group.add(text);

        return group;
    }

    function deg(rad)
    {
        return (rad/Math.PI)*180.0;
    }

     function draw_locations(json)
    {
        console.log(json);
        var sun_pos = json.sun;
        sun_symbol = draw_symbol(json.sun, '☉', 0.2, Math.floor(deg(json.sun.alt))+"°", 0.1);
        moon_symbol = draw_symbol(json.moon, '☽', 0.15, Math.floor(deg(json.moon.alt))+"°", 0.1);
        
        
        compass_group.add(sun_symbol);        
        compass_group.add(moon_symbol);                
    }

    request("/astro/transits", json=>{draw_transits(json)});
    request("/astro/analemma", json=>{draw_analemma(json)});
    request("/astro/locations", json=>{draw_locations(json)});

   
    function updateSecond()
    {        
        request('/keepalive', json => {});
    }

    // Widgets registered here
    widgets = {"forecast":widget_forecast, 
              "location":widget_location,
              "date":widget_date,
              "time":widget_time};

    
    // Update all widgets
    for(widget in widgets) {if(widgets[widget].init) widgets[widget].init();}
    for(widget in widgets) {widgets[widget].update();}

    
</script>
