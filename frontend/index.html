<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="fonts/geosanslight/stylesheet.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<body>
    <div id="drawing"></div>    
  </body>
<script type="text/javascript" src="js/extern/svg.min.js"></script>
<script type="text/javascript" src="js/extern/gl-matrix-min.js"></script>
<script type="text/javascript" src="js/extern/opentype.min.js"></script>

<!-- widgets -->
<script type="text/javascript" src="js/widget_location.js"></script>

<script type="text/javascript" src="js/utils/labels.js"></script>
<script type="text/javascript" src="js/utils/perspective.js"></script>
<script type="text/javascript" src="js/widget_text_forecast.js"></script>
<script type="text/javascript" src="js/widget_date.js"></script>
<script type="text/javascript" src="js/widget_time.js"></script>
<script type="text/javascript" src="js/widget_rose.js"></script>
<script type="text/javascript" src="js/widget_main_temperature.js"></script>
<script type="text/javascript" src="js/config.js"></script>
<script type="text/javascript" src="js/schedule.js"></script>
<script type="text/javascript" src="js/utils.js"></script>


Proper object-orientation for widgets.
Exception handling on updates.
Link updates to data to widgets
Icons/sprite sheet
Styling should be factored out in palettes, sizes, etc.
Update w/o flicker


<script>

    // Fetch a URL (via GET), parse as JSON and
    // send to the given callback
    function request(url, callback)
    {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {                
                callback(JSON.parse(this.responseText));
            }
        };
        request.open('GET', url);
        request.send();
    }

    

    // Fetch a URL (via GET), 
    // send to the given callback (as a raw string)
    function raw_request(url, callback)
    {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                callback(this.responseText);
            }
        };
        request.open('GET', url);
        request.send();
    }

    var draw = SVG('drawing').size(1080, 1920);
    var rect = draw.rect(1080, 1920).attr({ fill: '#000' })
    var time_group = draw.group()
    //bold_dictionary({"k":"value"}, {"fill":"#fff"}, {"fill":"#888"});
    
    // Widgets registered here
    widgets = {"today_forecast":widget_forecast, 
                "gnomon":widget_rose,
              "location":widget_location,
              "date":widget_date,
              "time":widget_time,
              "main_temperature":widget_main_temperature};



   

   
// the scheduler call; started after initialising complete
function updateSecond()
{                
    schedule_fetch();
}    

function init(skeleton_group)
{
    // Initialise all widgets
    for(widget in widgets) 
        {
            if(widgets[widget].init) 
            {
                var skeleton_widget = SVG.get(widget);
                
                if(skeleton_widget)
                {
                    bbox = skeleton_widget.rbox(draw);                
                    draw.rect(bbox.w, bbox.h).move(bbox.x,bbox.y).fill('none').stroke('#f0f');
                }
                else
                    bbox = {w:0, h:0, x:0, y:0};
                widgets[widget].init(bbox);
            
            }
        }

    schedule_fetch(); // initial call to scheduler on start
    var second_timer = setInterval(updateSecond,1000);
}


// Get the skeleton document which has the layout information
raw_request("/assets/prototype_8_skeleton.svg", svg=>{
    var skeleton_group = draw.group();
    skeleton_group.svg(svg);
    skeleton_group.attr({'visibility':'hidden'})
    init(skeleton_group);    
});

     

  

                
      
    
</script>
